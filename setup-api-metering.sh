#!/bin/bash

# =============================================================================
# Setup API Metering (Phase 119)
# Monetization Engine & Atomic Billing
# =============================================================================

echo "Setting up Monetization Engine..."
echo "================================================="
echo ""

# 1. Database Schema
echo "1. Generating SQL Schema..."
echo "   [!] Run this in Supabase SQL Editor:"

cat <<EOF > api_metering_schema.sql
-- Wallets Table
CREATE TABLE public.user_wallets (
    user_id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,
    balance bigint DEFAULT 0 NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Logs Table
CREATE TABLE public.api_usage_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users,
    api_key_id uuid REFERENCES public.api_keys(id),
    endpoint text,
    status integer,
    cost integer,
    latency_ms integer,
    ip_address text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS
ALTER TABLE public.user_wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_usage_logs ENABLE ROW LEVEL SECURITY;

-- Policy: Users see own wallet/logs
CREATE POLICY "Users view own wallet" ON public.user_wallets FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users view own logs" ON public.api_usage_logs FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- ATOMIC METERING FUNCTION (RPC)
-- This is the core engine. It checks balance AND deducts in one transaction.
CREATE OR REPLACE FUNCTION public.meter_api_request(
    p_key_hash text,
    p_cost integer,
    p_endpoint text,
    p_ip text
)
RETURNS TABLE (
    allowed boolean,
    user_id uuid,
    key_id uuid,
    new_balance bigint,
    error text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS \$\$
DECLARE
    v_user_id uuid;
    v_key_id uuid;
    v_balance bigint;
BEGIN
    -- 1. Validate Key
    SELECT k.user_id, k.id INTO v_user_id, v_key_id
    FROM public.api_keys k
    WHERE k.key_hash = p_key_hash AND k.is_active = true;

    IF v_user_id IS NULL THEN
        RETURN QUERY SELECT false, NULL::uuid, NULL::uuid, 0::bigint, 'Invalid API Key';
        RETURN;
    END IF;

    -- 2. Check & Update Wallet (Row Lock)
    UPDATE public.user_wallets
    SET balance = balance - p_cost,
        updated_at = now()
    WHERE user_id = v_user_id AND balance >= p_cost
    RETURNING balance INTO v_balance;

    IF v_balance IS NULL THEN
        -- Update failed means insufficient funds (or no wallet)
        RETURN QUERY SELECT false, v_user_id, v_key_id, 0::bigint, 'Insufficient Balance';
        RETURN;
    END IF;

    -- 3. Log Valid Request (Async-ish usually, but here sync is safer for audit)
    INSERT INTO public.api_usage_logs (user_id, api_key_id, endpoint, status, cost, ip_address)
    VALUES (v_user_id, v_key_id, p_endpoint, 200, p_cost, p_ip);

    RETURN QUERY SELECT true, v_user_id, v_key_id, v_balance, NULL;
END;
\$\$;
EOF
echo "   [✓] api_metering_schema.sql created."
echo ""

# 2. Middleware Helper
echo "2. Creating Logic: src/lib/api-metering.ts"

cat <<EOF > src/lib/api-metering.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { hashKey, getPrefix } from '@/lib/api-security';

// Pricing Config
const DEFAULT_COST = 50; // IDR per request

export async function handleMeteredRequest(req: NextRequest) {
    // 1. Extract Key
    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return NextResponse.json({ error: 'Missing API Key' }, { status: 401 });
    }
    const rawKey = authHeader.replace('Bearer ', '');
    const hashed = hashKey(rawKey);

    // 2. Validate & Bill (RPC)
    // We strictly use Supabase Client to call the RPC
    const response = NextResponse.next();
    const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
            cookies: {
                getAll: () => req.cookies.getAll(),
                setAll: () => {}, // Middleware cant set cookies easily in this context without request manipulation
            },
        }
    );

    const { data, error } = await supabase.rpc('meter_api_request', {
        p_key_hash: hashed,
        p_cost: DEFAULT_COST,
        p_endpoint: req.nextUrl.pathname,
        p_ip: req.ip || 'unknown'
    });

    if (error || !data || data.length === 0) {
        console.error('Metering Error:', error);
        return NextResponse.json({ error: 'System Error' }, { status: 500 });
    }

    const result = data[0];

    if (!result.allowed) {
        return NextResponse.json({ 
            error: result.error || 'Unauthorized',
            code: result.error === 'Insufficient Balance' ? 'PAYMENT_REQUIRED' : 'UNAUTHORIZED'
        }, { status: result.error === 'Insufficient Balance' ? 402 : 401 });
    }

    // 3. Success -> Pass valid headers downstream
    // We can add headers so the app knows who the API user is
    const newHeaders = new Headers(req.headers);
    newHeaders.set('x-api-user-id', result.user_id);
    newHeaders.set('x-api-key-id', result.key_id);

    return NextResponse.next({
        request: {
            headers: newHeaders,
        },
    });
}
EOF
echo "   [✓] Metering logic created."
echo ""

# Instructions
echo "================================================="
echo "Setup Complete!"
echo ""
echo "Next Steps:"
echo "1. Run the SQL schema in Supabase."
echo "2. Update src/middleware.ts to use 'handleMeteredRequest' for /api/v1/* routes."
