-- ============================================================================
-- API Metering Schema (Phase 119)
-- Monetization Engine & Atomic Billing
-- ============================================================================

-- 1. User Wallets Table
CREATE TABLE IF NOT EXISTS public.user_wallets (
    user_id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,
    balance bigint DEFAULT 0 NOT NULL CHECK (balance >= 0),
    currency text DEFAULT 'IDR' NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. API Usage Logs Table
CREATE TABLE IF NOT EXISTS public.api_usage_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users,
    api_key_id uuid,
    endpoint text NOT NULL,
    method text,
    status integer,
    cost integer NOT NULL,
    latency_ms integer,
    ip_address text,
    user_agent text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 3. Indexes for Performance
CREATE INDEX IF NOT EXISTS idx_wallets_user ON public.user_wallets(user_id);
CREATE INDEX IF NOT EXISTS idx_logs_user ON public.api_usage_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_logs_created ON public.api_usage_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_logs_api_key ON public.api_usage_logs(api_key_id);

-- 4. Enable RLS
ALTER TABLE public.user_wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_usage_logs ENABLE ROW LEVEL SECURITY;

-- 5. Drop existing policies if they exist
DROP POLICY IF EXISTS "Users view own wallet" ON public.user_wallets;
DROP POLICY IF EXISTS "Users view own logs" ON public.api_usage_logs;
DROP POLICY IF EXISTS "Service role full access wallets" ON public.user_wallets;
DROP POLICY IF EXISTS "Service role full access logs" ON public.api_usage_logs;

-- 6. RLS Policies
CREATE POLICY "Users view own wallet"
ON public.user_wallets
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users view own logs"
ON public.api_usage_logs
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Service role full access wallets"
ON public.user_wallets
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

CREATE POLICY "Service role full access logs"
ON public.api_usage_logs
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- 7. ATOMIC METERING FUNCTION
-- This is the core monetization engine
-- It validates API key, checks balance, deducts cost, and logs usage in ONE atomic transaction
CREATE OR REPLACE FUNCTION public.meter_api_request(
    p_key_hash text,
    p_cost integer,
    p_endpoint text,
    p_method text DEFAULT 'GET',
    p_ip text DEFAULT 'unknown'
)
RETURNS TABLE (
    allowed boolean,
    user_id uuid,
    key_id uuid,
    new_balance bigint,
    error text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid;
    v_key_id uuid;
    v_balance bigint;
    v_is_active boolean;
BEGIN
    -- 1. Validate API Key
    SELECT k.user_id, k.id, k.is_active
    INTO v_user_id, v_key_id, v_is_active
    FROM public.api_keys k
    WHERE k.key_hash = p_key_hash;

    -- Check if key exists
    IF v_user_id IS NULL THEN
        RETURN QUERY SELECT false, NULL::uuid, NULL::uuid, 0::bigint, 'Invalid API Key'::text;
        RETURN;
    END IF;

    -- Check if key is active
    IF v_is_active = false THEN
        RETURN QUERY SELECT false, v_user_id, v_key_id, 0::bigint, 'API Key Disabled'::text;
        RETURN;
    END IF;

    -- 2. Deduct from Wallet (WITH ROW LOCK)
    -- This ensures atomic operation - no race conditions
    UPDATE public.user_wallets
    SET 
        balance = balance - p_cost,
        updated_at = now()
    WHERE user_id = v_user_id 
    AND balance >= p_cost
    RETURNING balance INTO v_balance;

    -- If update affected 0 rows, insufficient balance
    IF NOT FOUND THEN
        -- Log failed attempt (optional - for analytics)
        INSERT INTO public.api_usage_logs (user_id, api_key_id, endpoint, method, status, cost, ip_address)
        VALUES (v_user_id, v_key_id, p_endpoint, p_method, 402, p_cost, p_ip);
        
        RETURN QUERY SELECT false, v_user_id, v_key_id, 0::bigint, 'Insufficient Balance'::text;
        RETURN;
    END IF;

    -- 3. Log Successful Request
    INSERT INTO public.api_usage_logs (user_id, api_key_id, endpoint, method, status, cost, ip_address)
    VALUES (v_user_id, v_key_id, p_endpoint, p_method, 200, p_cost, p_ip);

    -- 4. Return Success
    RETURN QUERY SELECT true, v_user_id, v_key_id, v_balance, NULL::text;
END;
$$;

-- 8. Function to top up wallet
CREATE OR REPLACE FUNCTION public.topup_wallet(
    p_user_id uuid,
    p_amount bigint
)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_new_balance bigint;
BEGIN
    -- Insert or update wallet
    INSERT INTO public.user_wallets (user_id, balance)
    VALUES (p_user_id, p_amount)
    ON CONFLICT (user_id) 
    DO UPDATE SET 
        balance = user_wallets.balance + p_amount,
        updated_at = now()
    RETURNING balance INTO v_new_balance;
    
    RETURN v_new_balance;
END;
$$;

-- 9. View for usage statistics
CREATE OR REPLACE VIEW public.view_api_usage_stats AS
SELECT 
    user_id,
    DATE(created_at) as date,
    COUNT(*) as request_count,
    SUM(cost) as total_cost,
    AVG(latency_ms) as avg_latency,
    COUNT(CASE WHEN status = 200 THEN 1 END) as successful_requests,
    COUNT(CASE WHEN status != 200 THEN 1 END) as failed_requests
FROM public.api_usage_logs
GROUP BY user_id, DATE(created_at);

-- Comments
COMMENT ON TABLE public.user_wallets IS 'User API credit balances';
COMMENT ON TABLE public.api_usage_logs IS 'API request logs for billing and analytics';
COMMENT ON FUNCTION public.meter_api_request IS 'Atomic function to validate, bill, and log API requests';
COMMENT ON FUNCTION public.topup_wallet IS 'Add credits to user wallet';
