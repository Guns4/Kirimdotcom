-- ============================================================================
-- API Metering Schema (Phase 119)
-- Monetization Engine & Atomic Billing
-- ============================================================================

-- 0. Create API Keys table if not exists
CREATE TABLE IF NOT EXISTS public.api_keys (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    name text NOT NULL,
    key_hash text UNIQUE NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Add index on key_hash for fast lookups
CREATE INDEX IF NOT EXISTS idx_api_keys_hash ON public.api_keys(key_hash);
CREATE INDEX IF NOT EXISTS idx_api_keys_user ON public.api_keys(user_id);

-- 1. User Wallets Table (Create base table)
CREATE TABLE IF NOT EXISTS public.user_wallets (
    user_id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Add columns if they don't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'user_wallets' AND column_name = 'balance') THEN
        ALTER TABLE public.user_wallets ADD COLUMN balance bigint DEFAULT 0 NOT NULL;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'user_wallets' AND column_name = 'currency') THEN
        ALTER TABLE public.user_wallets ADD COLUMN currency text DEFAULT 'IDR' NOT NULL;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'user_wallets' AND column_name = 'updated_at') THEN
        ALTER TABLE public.user_wallets ADD COLUMN updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL;
    END IF;
END $$;

-- Add constraint if not exists
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'user_wallets_balance_check') THEN
        ALTER TABLE public.user_wallets ADD CONSTRAINT user_wallets_balance_check CHECK (balance >= 0);
    END IF;
END $$;

-- 2. API Usage Logs Table (Create base table with minimal columns)
CREATE TABLE IF NOT EXISTS public.api_usage_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    endpoint text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Add columns if they don't exist (INCLUDING cost!)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'cost') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN cost integer NOT NULL DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'user_id') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN user_id uuid REFERENCES auth.users;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'api_key_id') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN api_key_id uuid;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'method') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN method text;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'status') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN status integer;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'latency_ms') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN latency_ms integer;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'ip_address') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN ip_address text;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'api_usage_logs' AND column_name = 'user_agent') THEN
        ALTER TABLE public.api_usage_logs ADD COLUMN user_agent text;
    END IF;
END $$;

-- 3. Indexes for Performance
CREATE INDEX IF NOT EXISTS idx_wallets_user ON public.user_wallets(user_id);
CREATE INDEX IF NOT EXISTS idx_logs_user ON public.api_usage_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_logs_created ON public.api_usage_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_logs_api_key ON public.api_usage_logs(api_key_id);

-- 4. Enable RLS
ALTER TABLE public.user_wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_usage_logs ENABLE ROW LEVEL SECURITY;

-- 5. Drop existing policies if they exist
DROP POLICY IF EXISTS "Users view own wallet" ON public.user_wallets;
DROP POLICY IF EXISTS "Users view own logs" ON public.api_usage_logs;
DROP POLICY IF EXISTS "Service role full access wallets" ON public.user_wallets;
DROP POLICY IF EXISTS "Service role full access logs" ON public.api_usage_logs;

-- 6. RLS Policies
CREATE POLICY "Users view own wallet"
ON public.user_wallets
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users view own logs"
ON public.api_usage_logs
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Service role full access wallets"
ON public.user_wallets
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

CREATE POLICY "Service role full access logs"
ON public.api_usage_logs
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- 7. ATOMIC METERING FUNCTION
-- This is the core monetization engine
-- It validates API key, checks balance, deducts cost, and logs usage in ONE atomic transaction
CREATE OR REPLACE FUNCTION public.meter_api_request(
    p_key_hash text,
    p_cost integer,
    p_endpoint text,
    p_method text DEFAULT 'GET',
    p_ip text DEFAULT 'unknown'
)
RETURNS TABLE (
    allowed boolean,
    user_id uuid,
    key_id uuid,
    new_balance bigint,
    error text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid;
    v_key_id uuid;
    v_balance bigint;
    v_is_active boolean;
BEGIN
    -- 1. Validate API Key
    SELECT k.user_id, k.id, k.is_active
    INTO v_user_id, v_key_id, v_is_active
    FROM public.api_keys k
    WHERE k.key_hash = p_key_hash;

    -- Check if key exists
    IF v_user_id IS NULL THEN
        RETURN QUERY SELECT false, NULL::uuid, NULL::uuid, 0::bigint, 'Invalid API Key'::text;
        RETURN;
    END IF;

    -- Check if key is active
    IF v_is_active = false THEN
        RETURN QUERY SELECT false, v_user_id, v_key_id, 0::bigint, 'API Key Disabled'::text;
        RETURN;
    END IF;

    -- 2. Deduct from Wallet (WITH ROW LOCK)
    -- This ensures atomic operation - no race conditions
    UPDATE public.user_wallets
    SET 
        balance = balance - p_cost,
        updated_at = now()
    WHERE user_id = v_user_id 
    AND balance >= p_cost
    RETURNING balance INTO v_balance;

    -- If update affected 0 rows, insufficient balance
    IF NOT FOUND THEN
        -- Log failed attempt (optional - for analytics)
        INSERT INTO public.api_usage_logs (user_id, api_key_id, endpoint, method, status, cost, ip_address)
        VALUES (v_user_id, v_key_id, p_endpoint, p_method, 402, p_cost, p_ip);
        
        RETURN QUERY SELECT false, v_user_id, v_key_id, 0::bigint, 'Insufficient Balance'::text;
        RETURN;
    END IF;

    -- 3. Log Successful Request
    INSERT INTO public.api_usage_logs (user_id, api_key_id, endpoint, method, status, cost, ip_address)
    VALUES (v_user_id, v_key_id, p_endpoint, p_method, 200, p_cost, p_ip);

    -- 4. Return Success
    RETURN QUERY SELECT true, v_user_id, v_key_id, v_balance, NULL::text;
END;
$$;

-- 8. Function to top up wallet
CREATE OR REPLACE FUNCTION public.topup_wallet(
    p_user_id uuid,
    p_amount bigint
)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_new_balance bigint;
BEGIN
    -- Insert or update wallet
    INSERT INTO public.user_wallets (user_id, balance)
    VALUES (p_user_id, p_amount)
    ON CONFLICT (user_id) 
    DO UPDATE SET 
        balance = user_wallets.balance + p_amount,
        updated_at = now()
    RETURNING balance INTO v_new_balance;
    
    RETURN v_new_balance;
END;
$$;

-- 9. Drop existing view if exists (to avoid column conflicts)
DROP VIEW IF EXISTS public.view_api_usage_stats;

-- 10. Recreate view for usage statistics (AFTER columns are added)
CREATE OR REPLACE VIEW public.view_api_usage_stats AS
SELECT 
    user_id,
    DATE(created_at) as date,
    COUNT(*) as request_count,
    SUM(cost) as total_cost,
    AVG(latency_ms) as avg_latency,
    COUNT(CASE WHEN status = 200 THEN 1 END) as successful_requests,
    COUNT(CASE WHEN status != 200 THEN 1 END) as failed_requests
FROM public.api_usage_logs
WHERE user_id IS NOT NULL
GROUP BY user_id, DATE(created_at);

-- Comments
COMMENT ON TABLE public.user_wallets IS 'User API credit balances';
COMMENT ON TABLE public.api_usage_logs IS 'API request logs for billing and analytics';
COMMENT ON FUNCTION public.meter_api_request IS 'Atomic function to validate, bill, and log API requests';
COMMENT ON FUNCTION public.topup_wallet IS 'Add credits to user wallet';
